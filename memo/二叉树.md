# 二叉树
## 二叉树理论基础/二叉树种类/二叉树存储方式/二叉树节点定义/二叉树遍历顺序

***满二叉树***
就是所有节点都是满的，直到叶子节点也都是2片叶子
求满二叉树节点数量是2的k次方，再减1：2^k -1。==》 k是深度，从根开始数，一层算1，一直到叶子节点

***完全二叉树***
和满二叉树不同，完全二叉树是除了底层以外，其他层都是满的，底层是从左到右连续的，底层不一定满，但是一定是连续的（从上到下，从左到右，编号连续才是完全二叉树），满二叉树一定是完全二叉树

***二叉搜索树***
既然加了搜索，就是节点便于搜索，节点便于搜索，那么它一定是有顺序的，搜索一个节点的时间复杂度是log n级别的。二叉搜索树对节点结构没固定要求，但是对节点上的元素要有一定顺序。

***平衡二叉搜索树***
在二叉搜索树的基础上，左子树和右子树的高度绝对值不能超过1
C++中map，set的底层实现都是平衡二叉搜索树，使用这些数据结构，往里插入节点是log n级别的，查询某一个元素也是log n级别的
map的key或者set里面的元素是不是有序的？当然是有序的，因为它底层是平衡二叉树。平衡二叉树就是要按元素的值来进行排序的。

***二叉树的存储方式***
1. 链式存储：用指针连左孩子连下一个节点、右孩子连接下一个节点
2. 线性存储：其实就是用一个数组来保存二叉树。比如怎么找到[a,b,c,d,e,f,g]第i个元素的左孩子和右孩子？左孩子2i+1，右孩子2i+2 

***二叉树就是个链表，伸出两个指针指向两个叶子节点***

***深度优先搜索***
一般都是用递归实现，用栈结构来实现递归。也可以用迭代法实现，迭代法就是非递归方式。理论上能用递归遍历就能用迭代遍历。
一般都是用递归方式搜索：
1. 前序遍历：中左右
2. 中序遍历：左中右
3. 后序遍历：左右中
（记不住就看“中”的位置，“中”在前就是前序，在中间就是中序，后面就是后序）

***广度优先搜索***
其实就是一层一层去遍历，或者一圈一圈去遍历，图论里是一圈圈遍历。二叉树里是一层一层遍历，广度优先搜索常见方式就是层序遍历


# 递归三部曲 
（leetcode 144，145，94）
1. 确定递归函数的参数和返回值: root
2. 确定终止条件: if(root===null)
3. 确定单层递归的逻辑: 以下三行代码：
res.push(root.val);
//递归左子树
dfs(root.left);
//递归右子树
dfs(root.right);

JS版本二叉树遍历
前序遍历：
```js
var preorderTraversal = function(root) {
// 第一种
//  let res=[];
//  const dfs=function(root){
//      if(root===null)return ;
//      //先序遍历所以从父节点开始
//      res.push(root.val);
//      //递归左子树
//      dfs(root.left);
//      //递归右子树
//      dfs(root.right);
//  }
//  //只使用一个参数 使用闭包进行存储结果
//  dfs(root);
//  return res;
// 第二种
  return root
    ? [
        // 前序遍历：中左右
        root.val,
        // 递归左子树
        ...preorderTraversal(root.left),
        // 递归右子树
        ...preorderTraversal(root.right),
      ]
    : [];
};
中序遍历

var inorderTraversal = function(root) {
// 第一种

    // let res=[];
    // const dfs=function(root){
    //     if(root===null){
    //         return ;
    //     }
    //     dfs(root.left);
    //     res.push(root.val);
    //     dfs(root.right);
    // }
    // dfs(root);
    // return res;

// 第二种
  return root
    ? [
        // 中序遍历：左中右
        // 递归左子树
        ...inorderTraversal(root.left),
        root.val,
        // 递归右子树
        ...inorderTraversal(root.right),
      ]
    : [];
};
后序遍历

var postorderTraversal = function(root) {
    // 第一种
    // let res=[];
    // const dfs=function(root){
    //     if(root===null){
    //         return ;
    //     }
    //     dfs(root.left);
    //     dfs(root.right);
    //     res.push(root.val);
    // }
    // dfs(root);
    // return res;

  // 第二种
  // 后续遍历：左右中
  return root
    ? [
        // 递归左子树
        ...postorderTraversal(root.left),
        // 递归右子树
        ...postorderTraversal(root.right),
        root.val,
      ]
    : [];
};
```

# 非递归遍历（迭代法）
前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。
为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是 ***中左右*** 的顺序。








