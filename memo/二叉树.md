# 二叉树
## 二叉树理论基础/二叉树种类/二叉树存储方式/二叉树节点定义/二叉树遍历顺序

***满二叉树***
就是所有节点都是满的，直到叶子节点也都是2片叶子
求满二叉树节点数量是2的k次方，再减1：2^k -1。==》 k是深度，从根开始数，一层算1，一直到叶子节点

***完全二叉树***
和满二叉树不同，完全二叉树是除了底层以外，其他层都是满的，底层是从左到右连续的，底层不一定满，但是一定是连续的（从上到下，从左到右，编号连续才是完全二叉树），满二叉树一定是完全二叉树

***二叉搜索树***
既然加了搜索，就是节点便于搜索，节点便于搜索，那么它一定是有顺序的，搜索一个节点的时间复杂度是log n级别的。二叉搜索树对节点结构没固定要求，但是对节点上的元素要有一定顺序。

***平衡二叉搜索树***
在二叉搜索树的基础上，左子树和右子树的高度绝对值不能超过1
C++中map，set的底层实现都是平衡二叉搜索树，使用这些数据结构，往里插入节点是log n级别的，查询某一个元素也是log n级别的
map的key或者set里面的元素是不是有序的？当然是有序的，因为它底层是平衡二叉树。平衡二叉树就是要按元素的值来进行排序的。

***二叉树的存储方式***
1. 链式存储：用指针连左孩子连下一个节点、右孩子连接下一个节点
2. 线性存储：其实就是用一个数组来保存二叉树。比如怎么找到[a,b,c,d,e,f,g]第i个元素的左孩子和右孩子？左孩子2i+1，右孩子2i+2 

***二叉树就是个链表，伸出两个指针指向两个叶子节点***

***深度优先搜索***
一般都是用递归实现，用栈结构来实现递归。也可以用迭代法实现，迭代法就是非递归方式。理论上能用递归遍历就能用迭代遍历。
一般都是用递归方式搜索：
1. 前序遍历：中左右
2. 中序遍历：左中右
3. 后序遍历：左右中
（记不住就看“中”的位置，“中”在前就是前序，在中间就是中序，后面就是后序）

***广度优先搜索***
其实就是一层一层去遍历，或者一圈一圈去遍历，图论里是一圈圈遍历。二叉树里是一层一层遍历，广度优先搜索常见方式就是层序遍历


# 递归三部曲 
（leetcode 144，145，94）
1. 确定递归函数的参数和返回值: root
2. 确定终止条件: if(root===null)
3. 确定单层递归的逻辑: 以下三行代码：
res.push(root.val);
//递归左子树
dfs(root.left);
//递归右子树
dfs(root.right);

JS版本二叉树遍历
前序遍历：
```js
var preorderTraversal = function(root) {
// 第一种
//  let res=[];
//  const dfs=function(root){
//      if(root===null)return ;
//      //先序遍历所以从父节点开始
//      res.push(root.val);
//      //递归左子树
//      dfs(root.left);
//      //递归右子树
//      dfs(root.right);
//  }
//  //只使用一个参数 使用闭包进行存储结果
//  dfs(root);
//  return res;
// 第二种
  return root
    ? [
        // 前序遍历：中左右
        root.val,
        // 递归左子树
        ...preorderTraversal(root.left),
        // 递归右子树
        ...preorderTraversal(root.right),
      ]
    : [];
};
中序遍历

var inorderTraversal = function(root) {
// 第一种

    // let res=[];
    // const dfs=function(root){
    //     if(root===null){
    //         return ;
    //     }
    //     dfs(root.left);
    //     res.push(root.val);
    //     dfs(root.right);
    // }
    // dfs(root);
    // return res;

// 第二种
  return root
    ? [
        // 中序遍历：左中右
        // 递归左子树
        ...inorderTraversal(root.left),
        root.val,
        // 递归右子树
        ...inorderTraversal(root.right),
      ]
    : [];
};
后序遍历

var postorderTraversal = function(root) {
    // 第一种
    // let res=[];
    // const dfs=function(root){
    //     if(root===null){
    //         return ;
    //     }
    //     dfs(root.left);
    //     dfs(root.right);
    //     res.push(root.val);
    // }
    // dfs(root);
    // return res;

  // 第二种
  // 后续遍历：左右中
  return root
    ? [
        // 递归左子树
        ...postorderTraversal(root.left),
        // 递归右子树
        ...postorderTraversal(root.right),
        root.val,
      ]
    : [];
};
```

# 非递归遍历（迭代法）
前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。
为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是 ***中左右*** 的顺序。

```js
// 前序遍历:

// 入栈 右 -> 左
// 出栈 中 -> 左 -> 右
var preorderTraversal = function(root, res = []) {
    if(!root) return res;
    const stack = [root];
    let cur = null;
    while(stack.length) {
        cur = stack.pop();
        res.push(cur.val);
        cur.right && stack.push(cur.right);
        cur.left && stack.push(cur.left);
    }
    return res;
};

// 中序遍历:

// 入栈 左 -> 右
// 出栈 左 -> 中 -> 右

var inorderTraversal = function(root, res = []) {
    const stack = [];
    let cur = root;
    while(stack.length || cur) {
        if(cur) {
            stack.push(cur);
            // 左
            cur = cur.left;
        } else {
            // --> 弹出 中
            cur = stack.pop();
            res.push(cur.val); 
            // 右
            cur = cur.right;
        }
    };
    return res;
};

// 后序遍历:

// 入栈 左 -> 右
// 出栈 中 -> 右 -> 左 结果翻转

var postorderTraversal = function(root, res = []) {
    if (!root) return res;
    const stack = [root];
    let cur = null;
    do {
        cur = stack.pop();
        res.push(cur.val);
        cur.left && stack.push(cur.left);
        cur.right && stack.push(cur.right);
    } while(stack.length);
    return res.reverse();
};
```

# 广度优先搜索（层序遍历）
层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。
需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。
队列，先进先出

1. 每层元素入队列，并记录这一层元素个数size
2. size的作用就是队列里有多层元素的时候，size记录当前层元素个数，每次弹出就减1，所以size为0的时候，这一层的元素都弹出了，队列里面剩下的就是下一层的元素
3. 最终返回是一个二维数组，每一层是一个一维数组

```js
var levelOrder = function(root) {
    //二叉树的层序遍历
    let res = [], queue = [];
    queue.push(root);
    if(root === null) {
        return res;
    }
    while(queue.length !== 0) {
        // 记录当前层级节点数
        let length = queue.length;
        //存放每一层的节点
        let curLevel = [];
        for(let i = 0;i < length; i++) {
            let node = queue.shift();
            curLevel.push(node.val);
            // 存放当前层下一层的节点
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
        //把每一层的结果放到结果数组
        res.push(curLevel);
    }
    return res;
};
```




