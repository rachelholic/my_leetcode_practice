# 动态规划 (灵神)
动态规划的核心就是 **状态定义** 和 **状态转移方程**

状态定义？状态转移方程？
启发思路：选或者不选/选哪个

DP萌新三步：
1. 思考回溯要怎么写
    1.1 入参和返回值
    1.2 递归到哪里
    1.3 递归边界和入口
2. 改成记忆化搜索
3. 1:1 翻译成递推

## DP模型：0-1背包和完全背包
选或不选的思想代表
```mermaid
graph TD
    A[选或不选] --> B[LC494. 目标和]
    A --> C[LC322. 零钱兑换]
    
    B --> D[回溯]
    B --> E[记忆化搜索]
    B --> F[递推]
    F --> G[空间优化: 两个数组]
    G --> H[空间优化: 一个数组]
    
    C --> I[同上（重点讲区别）]
    C --> J[完全背包]
    C --> K[常见变形]
```

## 打家劫舍


## 0-1背包
有n**个**物品，第i个物品的体积为w[i]，价值为v[i]，每个物品至多选一个，求体积和不超过capacity时多最大价值和
**回溯三问：**
1. 当前操作？枚举**第**i个物品选或不选：
                        不选，剩余容量不变；
                        选，剩余容量减少w[i]

2. 子问题？在剩余容量为c时，从**前**i个物品中得到的最大价值和

3. 下一个子问题？分类讨论：
                不选：在剩余容量为c时，从**前**i-1个物品中得到的最大价值和
                选：在剩余容量为c-w[i]时，从i-1个物品中得到的最大价值和
                dfs(i,c)=max(dfs(i-1, c), dfs(i-1, c-w[i])+v[i])

**常见变形**
1. 至多装capacity，求方案数/最大价值和
2. **恰好**装capacity，求**方案数**/最大/最小价值和
3. 至少装capacity，求方案数/最小价值和
dfs(i,c)=dfs(i-1, c) + dfs(i-1, c-w[i])+v[i]  ==》其实就是把上面的最大值改成加法
494. 目标和


0-1背包code
```python
# capacity: 背包容量
# w[i]: 第i个物品体积
# v[i]: 第i个物品价值
# 返回：所选物品体积和不超过capacity的前提下，所能得到的最大价值和
def zero_one_knapsack(capcity: int, w: List[int], v: List[int]) -> int:
    n = len(w) # 拿到数组长度

    @cache # 如果用记忆化搜索，就用python的@cache装饰器
    def dfs(i, c) # 定义递归函数
        if i < 0:        # 判断边界条件，i<0此时一个物品都没有了，直接返回0
            return 0
        if c < w[i]:  # 分类讨论，如果选的这个物品的体积已经超过剩余容量c了，只能不选
            return dfs(i-1, c)
        return max(dfs(i-1, c), dfs(i-1, c-w[i]) + v[i]) # 否则取个最大值

    return dfs(n-1, capacity) # 最后return从最后一个物品开始，容量是初始容量
```

## 完全背包
有n**种**物品，**第**i种物品的体积为w[i]，价值为v[i]，每种物品无限次重复选，求体积和不草果capacity时的最大价值和

**回溯三问：**
当前操作？枚举**第**i种物品选一个或不选：
    不选，剩余容量不变；
    选一个，剩余容量减少w[i]

子问题？在剩余容量为c时，从**前**i种物品中得到的最大价值和

下一个子问题？分类讨论：
    不选：在剩余容量为c时，从**前**i-1种物品中得到的最大价值和
    选一个：在剩余容量为c-w[i]时，从**前**i种物品中得到最大价值和

dfs(i,c)=max(dfs(i-1,c), dfs(i, c-w[i])+v[i])

**常见变形**
1. 至多装capacity，求方案数/最大价值和
2. **恰好**装capacity，求方案数/最大/**最小价值和** 
3. 至少装capacity，求方案数/最小价值和

这里和0-1背包的区别在于，不是n**个**物品，而是n**种**物品，无限次重复选，选了一个物品之后，i是不变的，可以继续选第i个物品
这里就不是递归到i-1了，而是递归到i
**最小价值和**：dfs(i,c)=min(dfs(i-1, c), dfs(i, c-w[i])+v[i])
322.零钱兑换


### 递归搜索 + 保存计算结果 = 记忆化搜索

# 动态规划 (代码随想录)
动规基础（有40道）
1. 爬楼梯/斐波那契数列
2. 背包问题（非常经典，大厂爱考）
3. 打家劫舍（leetcode上一共就三道）
4. 股票问题（今天买哪天卖最大利益化）
5. 子序列问题（一般都是求最长递增子序列、最长连续子序列、经典的编辑距离问题）
其他概率之类的dp问题都是竞赛类的题目，一般大厂都不考

# 动归的误区
解题的时候看题解，都是把精力放到了递推公式上，但其实公式只是一部分，很多人都是看了题解，找到公式，稀里糊涂照葫芦画瓢解题，之后遇到新题，继续看题解，稀里糊涂解题如此循环。。。因为没掌握本质

# DP五部曲
1. 一定要知道**dp数组定义以及下标**的含义：比如dp[i][j], i是什么意思，j又是什么意思
2. 递推公式
3. dp数组如何初始化
4. 遍历顺序（背包）
5. 打印dp数组 （看是不是按照我们的逻辑处理的）






